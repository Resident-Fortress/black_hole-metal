#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) writeonly uniform image2D outImage;
layout(std140, binding = 1) uniform Camera {
    vec3 camPos;     float _pad0;
    vec3 camRight;   float _pad1;
    vec3 camUp;      float _pad2;
    vec3 camForward; float _pad3;
    float tanHalfFov;
    float aspect;
    bool moving;
    int   _pad4;
} cam;

layout(std140, binding = 2) uniform Disk {
    float disk_r1;
    float disk_r2;
    float disk_num;
    float thickness;
};

layout(std140, binding = 3) uniform Objects {
    int numObjects;
    vec4 objPosRadius[16];
    vec4 objColor[16];
    float  mass[16]; 
};

// Enhanced constants for photorealism
const float SagA_rs = 1.269e10;
const float D_LAMBDA = 1e7;
const double ESCAPE_R = 1e30;
const float PI = 3.14159265359;
const float DOPPLER_FACTOR = 0.3;
const float REDSHIFT_INTENSITY = 1.5;

// Globals to store hit info and enhanced lighting data
vec4 objectColor = vec4(0.0);
vec3 hitCenter = vec3(0.0);
float hitRadius = 0.0;
float timeTravel = 0.0; // For gravitational time dilation effects

// Enhanced photorealistic functions
vec3 blackbodySpectrum(float temperature) {
    // Simplified blackbody radiation for accretion disk
    float r = clamp(1.0 - exp(-6000.0 / temperature), 0.0, 1.0);
    float g = clamp(1.0 - exp(-4000.0 / temperature), 0.0, 1.0);
    float b = clamp(1.0 - exp(-2000.0 / temperature), 0.0, 1.0);
    return vec3(r, g, b);
}

vec3 dopplerShift(vec3 color, float velocity) {
    // Simulate Doppler shifting of light
    float factor = 1.0 + velocity * DOPPLER_FACTOR;
    return color * factor;
}

float gravitationalRedshift(float r) {
    // Calculate gravitational redshift based on distance from black hole
    return sqrt(1.0 - SagA_rs / r);
}

struct Ray {
    float x, y, z, r, theta, phi;
    float dr, dtheta, dphi;
    float E, L;
};
Ray initRay(vec3 pos, vec3 dir) {
    Ray ray;
    ray.x = pos.x; ray.y = pos.y; ray.z = pos.z;
    ray.r = length(pos);
    ray.theta = acos(pos.z / ray.r);
    ray.phi = atan(pos.y, pos.x);

    float dx = dir.x, dy = dir.y, dz = dir.z;
    ray.dr     = sin(ray.theta)*cos(ray.phi)*dx + sin(ray.theta)*sin(ray.phi)*dy + cos(ray.theta)*dz;
    ray.dtheta = (cos(ray.theta)*cos(ray.phi)*dx + cos(ray.theta)*sin(ray.phi)*dy - sin(ray.theta)*dz) / ray.r;
    ray.dphi   = (-sin(ray.phi)*dx + cos(ray.phi)*dy) / (ray.r * sin(ray.theta));

    ray.L = ray.r * ray.r * sin(ray.theta) * ray.dphi;
    float f = 1.0 - SagA_rs / ray.r;
    float dt_dL = sqrt((ray.dr*ray.dr)/f + ray.r*ray.r*(ray.dtheta*ray.dtheta + sin(ray.theta)*sin(ray.theta)*ray.dphi*ray.dphi));
    ray.E = f * dt_dL;

    return ray;
}

bool intercept(Ray ray, float rs) {
    return ray.r <= rs;
}
// Returns true on hit, captures center, radius, and base color
bool interceptObject(Ray ray) {
    vec3 P = vec3(ray.x, ray.y, ray.z);
    for (int i = 0; i < numObjects; ++i) {
        vec3 center = objPosRadius[i].xyz;
        float radius = objPosRadius[i].w;
        if (distance(P, center) <= radius) {
            objectColor = objColor[i];
            hitCenter = center;
            hitRadius = radius;
            return true;
        }
    }
    return false;
}

void geodesicRHS(Ray ray, out vec3 d1, out vec3 d2) {
    float r = ray.r, theta = ray.theta;
    float dr = ray.dr, dtheta = ray.dtheta, dphi = ray.dphi;
    float f = 1.0 - SagA_rs / r;
    float dt_dL = ray.E / f;

    d1 = vec3(dr, dtheta, dphi);
    d2.x = - (SagA_rs / (2.0 * r*r)) * f * dt_dL * dt_dL
         + (SagA_rs / (2.0 * r*r * f)) * dr * dr
         + r * (dtheta*dtheta + sin(theta)*sin(theta)*dphi*dphi);
    d2.y = -2.0*dr*dtheta/r + sin(theta)*cos(theta)*dphi*dphi;
    d2.z = -2.0*dr*dphi/r - 2.0*cos(theta)/(sin(theta)) * dtheta * dphi;
}
void rk4Step(inout Ray ray, float dL) {
    vec3 k1a, k1b;
    geodesicRHS(ray, k1a, k1b);

    ray.r      += dL * k1a.x;
    ray.theta  += dL * k1a.y;
    ray.phi    += dL * k1a.z;
    ray.dr     += dL * k1b.x;
    ray.dtheta += dL * k1b.y;
    ray.dphi   += dL * k1b.z;

    ray.x = ray.r * sin(ray.theta) * cos(ray.phi);
    ray.y = ray.r * sin(ray.theta) * sin(ray.phi);
    ray.z = ray.r * cos(ray.theta);
}
bool crossesEquatorialPlane(vec3 oldPos, vec3 newPos) {
    bool crossed = (oldPos.y * newPos.y < 0.0);
    float r = length(vec2(newPos.x, newPos.z));
    return crossed && (r >= disk_r1 && r <= disk_r2);
}

// Enhanced light beam generation for visible interactions
vec3 generateLightBeam(vec3 position, float intensity) {
    // Create visible light beams that interact with spacetime curvature
    float distance = length(position);
    float attenuation = 1.0 / (1.0 + 0.1 * distance * distance / (SagA_rs * SagA_rs));
    
    // Create beam pattern
    float beamIntensity = intensity * attenuation;
    vec3 beamColor = vec3(0.8, 0.9, 1.0) * beamIntensity;
    
    // Add gravitational lensing effect to the beam
    float lensing = 1.0 + SagA_rs / distance;
    return beamColor * lensing;
}

// Enhanced accretion disk rendering with temperature gradients
vec3 calculateDiskColor(vec3 position, float r) {
    // Temperature decreases with distance from black hole
    float temperature = 50000.0 * pow(SagA_rs / (r * 1e10), 0.75);
    temperature = clamp(temperature, 2000.0, 100000.0);
    
    // Get blackbody spectrum
    vec3 diskColor = blackbodySpectrum(temperature);
    
    // Add gravitational redshift
    float redshift = gravitationalRedshift(r);
    diskColor *= redshift * REDSHIFT_INTENSITY;
    
    // Add some turbulence and detail
    float noise = sin(r * 0.0001) * cos(position.x * 0.0001) * sin(position.z * 0.0001);
    diskColor *= (1.0 + 0.3 * noise);
    
    // Add radial brightness variation
    float radialFalloff = 1.0 - smoothstep(disk_r1, disk_r2, r);
    diskColor *= radialFalloff;
    
    return diskColor;
}

void main() {
    int WIDTH  = cam.moving ? 200 : 400;
    int HEIGHT = cam.moving ? 150 : 300;

    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= WIDTH || pix.y >= HEIGHT) return;

    // Init Ray
    float u = (2.0 * (pix.x + 0.5) / WIDTH - 1.0) * cam.aspect * cam.tanHalfFov;
    float v = (1.0 - 2.0 * (pix.y + 0.5) / HEIGHT) * cam.tanHalfFov;
    vec3 dir = normalize(u * cam.camRight - v * cam.camUp + cam.camForward);
    Ray ray = initRay(cam.camPos, dir);

    vec4 color = vec4(0.0);
    vec3 prevPos = vec3(ray.x, ray.y, ray.z);
    float lambda = 0.0;
    timeTravel = 0.0;

    bool hitBlackHole = false;
    bool hitDisk      = false;
    bool hitObject    = false;
    
    // Enhanced light beam tracking
    vec3 lightBeamAccumulation = vec3(0.0);
    float beamIntensity = 0.0;

    int steps = cam.moving ? 40000 : 80000;

    for (int i = 0; i < steps; ++i) {
        if (intercept(ray, SagA_rs)) { 
            hitBlackHole = true; 
            break; 
        }
        
        // Accumulate gravitational time dilation
        float gravitationalPotential = -SagA_rs / (2.0 * ray.r);
        timeTravel += gravitationalPotential * D_LAMBDA;
        
        // Add light beam interaction
        if (ray.r < 5.0 * SagA_rs) {
            float beamStrength = exp(-ray.r / SagA_rs) * 0.1;
            lightBeamAccumulation += generateLightBeam(vec3(ray.x, ray.y, ray.z), beamStrength);
            beamIntensity += beamStrength;
        }
        
        rk4Step(ray, D_LAMBDA);
        lambda += D_LAMBDA;

        vec3 newPos = vec3(ray.x, ray.y, ray.z);
        if (crossesEquatorialPlane(prevPos, newPos)) { 
            hitDisk = true; 
            break; 
        }
        if (interceptObject(ray)) { 
            hitObject = true; 
            break; 
        }
        prevPos = newPos;
        if (ray.r > ESCAPE_R) break;
    }

    // Enhanced color calculation with photorealistic effects
    if (hitDisk) {
        float r = length(vec3(ray.x, ray.y, ray.z));
        vec3 diskColor = calculateDiskColor(vec3(ray.x, ray.y, ray.z), r);
        
        // Add gravitational lensing brightness enhancement
        float lensing = 1.0 + 2.0 * SagA_rs / r;
        diskColor *= lensing;
        
        // Combine with light beams
        diskColor += lightBeamAccumulation * 0.5;
        
        color = vec4(diskColor, 1.0);

    } else if (hitBlackHole) {
        // Enhanced event horizon with Hawking radiation glow
        float hawkingGlow = exp(-lambda / (SagA_rs * 1000.0)) * 0.05;
        vec3 horizonColor = vec3(hawkingGlow * 0.1, hawkingGlow * 0.05, hawkingGlow * 0.2);
        horizonColor += lightBeamAccumulation * 0.1;
        color = vec4(horizonColor, 1.0);

    } else if (hitObject) {
        // Enhanced object shading with gravitational effects
        vec3 P = vec3(ray.x, ray.y, ray.z);
        vec3 N = normalize(P - hitCenter);
        vec3 V = normalize(cam.camPos - P);
        
        // Enhanced lighting model
        float ambient = 0.1;
        float diff = max(dot(N, V), 0.0);
        
        // Add gravitational lensing to object brightness
        float distance = length(P);
        float lensing = 1.0 + SagA_rs / distance;
        
        float intensity = ambient + (1.0 - ambient) * diff * lensing;
        vec3 shaded = objectColor.rgb * intensity;
        
        // Add light beam interactions
        shaded += lightBeamAccumulation * 0.3;
        
        color = vec4(shaded, objectColor.a);

    } else {
        // Enhanced background with visible light beams and cosmic background
        vec3 background = vec3(0.01, 0.01, 0.03); // Deep space blue
        
        // Add visible light beams in empty space
        background += lightBeamAccumulation;
        
        // Add some stars/cosmic background
        float starField = sin(u * 1000.0) * cos(v * 1000.0);
        if (starField > 0.999) {
            background += vec3(1.0, 0.9, 0.8) * 0.3;
        }
        
        color = vec4(background, 1.0);
    }

    // Apply time dilation color effects
    float timeDilationFactor = 1.0 + timeTravel * 0.00001;
    color.rgb *= timeDilationFactor;

    imageStore(outImage, pix, color);
}
